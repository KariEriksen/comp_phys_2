\section{Method}

\subsection{Gibbs sampling}

Our Gibbs sampler works quite simple updating the hidden nodes according to \eqref{eq:hidden}, a listing of the code can be seen below. For each number of hidden unit we calculate the new value hj(j) given the conditional probability.

\begin{lstlisting}
    for(int j = 0; j < N; j++){

        double sum_xi_wij = 0;
        for(int i = 0; i < M; i++){
            sum_xi_wij += R(i)*psi_t.W(i, j);
        }

        double Hj = psi_t.b(j) + (sum_xi_wij/sigma_sq);
        double z = 1/(1 + exp(-Hj));

        hj(j) = z;
    }
\end{lstlisting}

As for the visible units they are drawn from a normal distribution according to \eqref{eq:visible} and an illustration is seen below. Here the mean is the variable my and standard deviation is $\sigma$.


\begin{lstlisting}
    for(int i = 0; i < M; i++){

        double sum_hj_wij = 0;
        for(int j = 0; j < N; j++){
            sum_hj_wij += psi_t.W(i, j)*hj(j);
        }
        double my = psi_t.a(i) + sum_hj_wij;
        //Creating a normal dist
        uniform_real_distribution<double> dis(my, sigma_sq);
        R(i) = dis(*gen);
    }
\end{lstlisting}

